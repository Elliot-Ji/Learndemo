参考笔记: https://shimo.im/docs/68cd6h3TwygPwx8W/read

1.用位运算实现 + - * /
     1.1 实现 +
            前置知识:理解
                       与运算(&)就是两个都为1才为1,结果才为1
                       或运算(|) 就是两个位都是0时,结果才为0
                       异或运算(^)就是无进位的相加(又或者 两个位相同为0,不同为1)
                           特征: 1. 0 ^ N = N
                                2.  N ^ N = 0
                                3. 几个数的异或运算,顺序改变不影响最后的结果
                       取反运算(~)就是 0变1,1变0
                            一个int a 的负数即为: 取反再加1
            int a = 46; int b = 20 --> a + b = (a ^ b) + (1 << (a & b))
            a ^ b =
            (1 << (a & b)) =
     1.2 实现 -
            a - b = a + (-b)
            -b = ~b + 1
     1.3 实现 *

2.常数操作

3.时间复杂度

基础知识:
1).并查集-->https://www.bilibili.com/video/BV1M44y1n78z?p=15&vd_source=b5f8254ef4878b9fdd7d9b9213accf9d

算法基础题目:
  1.链表相关
       (1).一个链表,找到倒数第K个节点
               思路: 双指针法
               首先一个指针移动K-1位（这里可以根据你的初始化指针决定），然后另一个指针开始启动，
               他俩移动速度一样，所以他俩始终相差K-1位，当第一个指针到达链表尾部时，第二个指针的指向则为倒数第K个节点。
           https://mp.weixin.qq.com/s?__biz=Mzg3Mzc0NjUzMQ==&mid=2247497046&idx=1&sn=8b8866933c2606801df4ed12c5025ef0&source=41#wechat_redirect
       (2).一个链表,返回链表的中间节点
       (3).单,双链表的反转练习
  2.队列和栈
       2.1 利用链表和数组实现队列和栈
       2.2 实现一个特殊的栈,在基本功能的基础上,再实现返回栈中最小元素的功能
              pop,push,getMin,时间 复杂度为O(1),设计的栈类型可以使用现成的栈结构
              思路:利用两个栈实现
       2.3 如何用栈结构实现队列结构? 思路: 利用两个栈,拼出一个队列
       2.4 如何用队列结构实现栈结构? 思路: 利用两个队列
  3.递归
       3.1 递归的思想: 从一个题目中思考: 一个数组,求数组中的最大值?(使用递归方法)
                  思路: 1.现将数组划分一半,求左边的最大值,右边的最大值,最后计算两边返回的值中的最大值
                  又类似平衡二叉树结构
       3.2 Master公式:用于分析递归函数的时间复杂度
                   T(N) = a*T(N/b) +O(Nd) n的d次方
                   前提都是以b为均分的递归,a,b,d都是常数

  4.哈希表和有序表
       4.1 哈希表-->HashMap  增删改查的每个方法的时间复杂度都为O(1)
            (1).按值传递还是按引用传递!!!!
                   key和value如果是基础数据类型(也包括基础包装类型),每新增一个数据时,这个数据有多大,就开辟多大的空间来存储
                       如果是引用类型,新增数据时,只保存内存地址到哈希表中(内存地址为8字节)
       4.2 有序表 ---> TreeMap: 接口名,实现有: 红黑树,avl,sb树,跳表 增删改查的每个方法的时间复杂度都为O(logN)
               (1).有序,

  5.归并排序







































