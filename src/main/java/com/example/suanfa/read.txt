参考笔记: https://shimo.im/docs/68cd6h3TwygPwx8W/read

1.用位运算实现 + - * /
     1.1 实现 +
            前置知识:理解
                       与运算(&)就是两个都为1才为1,结果才为1
                       或运算(|) 就是两个位都是0时,结果才为0
                       异或运算(^)就是无进位的相加(又或者 两个位相同为0,不同为1)
                           特征: 1. 0 ^ N = N
                                2.  N ^ N = 0
                                3. 几个数的异或运算,顺序改变不影响最后的结果
                       取反运算(~)就是 0变1,1变0
                            一个int a 的负数即为: 取反再加1
            int a = 46; int b = 20 --> a + b = (a ^ b) + (1 << (a & b))
            a ^ b =
            (1 << (a & b)) =
     1.2 实现 -
            a - b = a + (-b)
            -b = ~b + 1
     1.3 实现 *

2.常数操作

3.时间复杂度

基础知识:
1).并查集-->https://www.bilibili.com/video/BV1M44y1n78z?p=15&vd_source=b5f8254ef4878b9fdd7d9b9213accf9d

算法基础题目:
  1.链表相关
       (1).一个链表,找到倒数第K个节点
               思路: 双指针法
               首先一个指针移动K-1位（这里可以根据你的初始化指针决定），然后另一个指针开始启动，
               他俩移动速度一样，所以他俩始终相差K-1位，当第一个指针到达链表尾部时，第二个指针的指向则为倒数第K个节点。
           https://mp.weixin.qq.com/s?__biz=Mzg3Mzc0NjUzMQ==&mid=2247497046&idx=1&sn=8b8866933c2606801df4ed12c5025ef0&source=41#wechat_redirect
       (2).一个链表,返回链表的中间节点
       (3).单,双链表的反转练习
  2.队列和栈
       2.1 利用链表和数组实现队列和栈
       2.2 实现一个特殊的栈,在基本功能的基础上,再实现返回栈中最小元素的功能
              pop,push,getMin,时间 复杂度为O(1),设计的栈类型可以使用现成的栈结构
              思路:利用两个栈实现
       2.3 如何用栈结构实现队列结构? 思路: 利用两个栈,拼出一个队列
       2.4 如何用队列结构实现栈结构? 思路: 利用两个队列
  3.递归
       3.1 递归的思想: 从一个题目中思考: 一个数组,求数组中的最大值?(使用递归方法)
                  思路: 1.现将数组划分一半,求左边的最大值,右边的最大值,最后计算两边返回的值中的最大值
                               实际结构为系统栈
                  分析递归时,画出逻辑图类似平衡二叉树结构
       3.2 Master公式:用于分析递归函数的时间复杂度
                   T(N) = a*T(N/b) +O(Nd) n的d次方
                   前提都是以b为均分的递归,a,b,d都是常数

  4.哈希表和有序表
       4.1 哈希表-->HashMap  增删改查的每个方法的时间复杂度都为O(1)
            (1).按值传递还是按引用传递!!!!
                   key和value如果是基础数据类型(也包括基础包装类型),每新增一个数据时,这个数据有多大,就开辟多大的空间来存储
                       如果是引用类型,新增数据时,只保存内存地址到哈希表中(内存地址为8字节)
       4.2 有序表 ---> TreeMap: 接口名,实现有: 红黑树,avl,sb树,跳表 增删改查的每个方法的时间复杂度都为O(logN)
               (1).有序,

  5.归并排序
       5.1 对一个数组排序,过程: 先对左半部分排序,再对又半部分排序,最后将排好序的左半边和排好序的右半边归并排序
       5.2 相关的三个题目: 题目1 小和问题,一个数组,每个位置的数的左边比自己小的数的和,最后所有和的累加
                         题目2:逆序对问题
                         题目3:大于2倍问题
                         题目4:
                                生成前缀和数组

  6.快速排序
       荷兰国旗问题

  7.堆结构
       7.1 比较器
       7.2 堆结构就是用数组实现的完全二叉树结构
           完全二叉树中如果每颗子树的最大值都在顶部就是大根堆
           完全二叉树中如果每颗子树的最小值都在顶部就是小根堆
           堆结构的heapInsert和heapify操作
           堆结构的增大和减少
           优先级队列结构,就是堆结构

               什么是完全二叉树?--->空树,叶子结点从左往右可以依次变满的二叉树
               用数组实现完全二叉树,数组下标按顺序放入完全二叉树的每个节点中,此时我们可以得出一个规律: 即计算每个节点的左孩子和右孩子,父节点
                 左: 2*i+1
                 右: 2*i+2
                 父: (i-1)/2
               什么是堆?要同时满足以下条件:
                  1.是完全二叉树
                  2.指明是大根堆还是小根堆
               如何实现堆排序?
                  1)一个无序数组先完成大根堆操作(或者小根堆)
                  2)将大根堆中的第一个位置的数和最后一个位置的数交换,然后 heapSize-1,再然后heapify操作(实现满足大根堆的操作)
                  3)重复以上第二步操作
  8.树
       8.1 前缀树
           计数排序
           基数排序  https://www.bilibili.com/video/BV1g3411i7of/?p=128&spm_id_from=pageDriver&vd_source=b5f8254ef4878b9fdd7d9b9213accf9d

  9.排序算法的稳定性
           算法         是否有稳定性                   时间复杂度
         选择排序              ×                       O(N²)
         冒泡排序        可以实现√     处理相等的情况      O(N²)
         插入排序        可以实现√     处理相等的情况      O(N²)
         归并排序        可以实现√     处理相等的情况      O(N*logN)
         快排                 ×                        O(N*logN)
         堆排序               ×                        O(N*logN)

  10.动态规划、KMP、Manacher算法   https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=13&vd_source=b5f8254ef4878b9fdd7d9b9213accf9d

      note： 23/5/19 截止p133，finish first
             https://www.bilibili.com/video/BV1g3411i7of/?p=133&spm_id_from=333.880.my_history.page.click&vd_source=b5f8254ef4878b9fdd7d9b9213accf9d
             second level: review  some sort suanfa


  刷题：23/8/1  =  https://www.bilibili.com/video/BV13g41157hK?p=30&vd_source=b5f8254ef4878b9fdd7d9b9213accf9d




































